## Optional Lab: Multiple Variable Linear Regression

- Goals
  1. Extend our regression models to support multiple features
     1. Extend Data Structures to support multple features
     2. Rewrite prediction, cost and gradient routines to support multiple features
     3. Utilize Numpy np.dot to vectorize their implementations for speed and simplicity

- In this lab, we use Numoy and Matplotlib

```
import copy, math
import numpy as np
import matplotlib.pyplot as plt
plt.style.use('./deeplearning.mplstyle')
np.set_printoptions(precision=2)  # reduced display precision on numpy arrays
```
- These are the libraries that we are importing

![image](https://github.com/user-attachments/assets/a6a080d6-1bec-4ea3-a2a2-c19a5083e2c6)

- Problem Statement

![image](https://github.com/user-attachments/assets/c30f1096-7647-4404-b93a-a7291535ee83)

![image](https://github.com/user-attachments/assets/3130fc64-ea5c-4911-a104-2e13f9061c1f)

- We present the data in the form of matrix

```
# data is stored in numpy array/matrix
print(f"X Shape: {X_train.shape}, X Type:{type(X_train)})")
print(X_train)
print(f"y Shape: {y_train.shape}, y Type:{type(y_train)})")
print(y_train)
```
![image](https://github.com/user-attachments/assets/5f08a23c-a9c4-4e85-b0a1-f1de43027d96)

- The parameters w and b
![image](https://github.com/user-attachments/assets/064ca6e8-a08e-42dd-b071-59e8729996eb)

![image](https://github.com/user-attachments/assets/3bb8c370-ac26-4c7c-9001-f4845bc95baa)

```
def predict_single_loop(x, w, b): 
    """
    single predict using linear regression
    
    Args:
      x (ndarray): Shape (n,) example with multiple features
      w (ndarray): Shape (n,) model parameters    
      b (scalar):  model parameter     
      
    Returns:
      p (scalar):  prediction
    """
    n = x.shape[0]
    p = 0
    for i in range(n):
        p_i = x[i] * w[i]  
        p = p + p_i         
    p = p + b                
    return p
```
- We define a simple program where we are passing three arguments, the X (training examples), the weights w and b
- It basically takes the no of eamples from x via the shape function and runs the loop for that many given times where each example number is multiplied by the given weight to return the prediction value

```
# get a row from our training data
x_vec = X_train[0,:]
print(f"x_vec shape {x_vec.shape}, x_vec value: {x_vec}")

# make a prediction
f_wb = predict_single_loop(x_vec, w_init, b_init)
print(f"f_wb shape {f_wb.shape}, prediction: {f_wb}")

Output-
x_vec shape (4,), x_vec value: [2104    5    1   45]
f_wb shape (), prediction: 459.9999976194083
```

- This is a very basic example, where we are getting the value of the function
- The function f_wb has no shape since it is a scalar and the shape function works only on arrays or arrays like data types where the output is not just one single value
- 
