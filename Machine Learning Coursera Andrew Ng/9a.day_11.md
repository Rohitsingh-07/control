## Vectorization - Part 1

- Vectorization is used to make code shorter and run it more efficiently
- Learning how to write vectorized code will allow you to also take advantage of modern numerical linear algebra libraries, as well as maybe even GPU hardware
- This is hardware objectively designed to speed up computer graphics in your computer, but turns out can be used when you write vectorized code to also help you execute your code much more quickly
- So, when we have a vector of data or say we have the data in an array, we do the computation manually or with the help of For loop. However, this is not an optimized way of coding and sometimes can be difficult to read
- These are the methods which are without vectorization
---
- When we talk about vectorization, it computes a dot product of the vectors in a single line of code with a numpy function dot
- Vectorization makes the code shorter and makes it run faster which is beneficial while computing
![image](https://github.com/user-attachments/assets/761870c4-8aac-4345-b6b2-11219de12706)

- Above is the representation of what I am trying to explain

---

## Vectorization - Part 2

- Without Vecotrization, when we need to calculate gradient descent or any computing, the machine performs first index calculation then second then third as in it goes from one index to another
- With Vectorization, the computer gets the multiple values of w and x and in a single step, it would multiply all the values of w and x at the same time in parallel
- This means that codes with vectorization can perform calculations in much less time than codes without vectorization.
- That's why being able to vectorize implementations of learning algorithms, has been a key step to getting learning algorithms to run efficiently, and therefore scale well to large datasets that many modern machine learning algorithms now have to operate on
![image](https://github.com/user-attachments/assets/2055153d-e231-4e04-bde2-16e774a35a2b)

- This is another example of why vectorization is better than other conventional methods

![image](https://github.com/user-attachments/assets/d8c39c22-3948-4ab4-a564-57a293cca05e)

---

## Optional lab: Python, NumPy and vectorization

- The first thing that we do is import the numpy library along with time
![image](https://github.com/user-attachments/assets/198fe5ca-2071-445a-8779-1b92c15c7936)

- NumPy Documentation including a basic introduction: NumPy.org
- A challenging feature topic: https://numpy.org/doc/stable/user/basics.broadcasting.html

- Python is the programming language we will be using in this course. It has a set of numeric data types and arithmetic operations. NumPy is a library that extends the base capabilities of python to add a richer data set including more numeric types, vectors, matrices, and many matrix functions. NumPy and python work together fairly seamlessly. Python arithmetic operators work on NumPy data types and many NumPy functions will accept python data types.

![image](https://github.com/user-attachments/assets/ce766f6e-268c-46ab-b0a8-b44b80dcd8b3)

```
# NumPy routines which allocate memory and fill arrays with value
a = np.zeros(4);                print(f"np.zeros(4) :   a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
a = np.zeros((4,));             print(f"np.zeros(4,) :  a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
a = np.random.random_sample(4); print(f"np.random.random_sample(4): a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
```
![image](https://github.com/user-attachments/assets/3df98687-36a6-421e-96ee-cf5eb323b19d)

- We see the three different methods through which we can specify an array
```
# NumPy routines which allocate memory and fill arrays with value but do not accept shape as input argument
a = np.arange(4.);              print(f"np.arange(4.):     a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
a = np.random.rand(4);          print(f"np.random.rand(4): a = {a}, a shape = {a.shape}, a data type = {a.dtype}")

# NumPy routines which allocate memory and fill with user specified values
a = np.array([5,4,3,2]);  print(f"np.array([5,4,3,2]):  a = {a},     a shape = {a.shape}, a data type = {a.dtype}")
a = np.array([5.,4,3,2]); print(f"np.array([5.,4,3,2]): a = {a}, a shape = {a.shape}, a data type = {a.dtype}")
```

- These have all created a one-dimensional vector a with four elements. a.shape returns the dimensions. Here we see a.shape = (4,) indicating a 1-d array with 4 elements.

```
#vector indexing operations on 1-D vectors
a = np.arange(10)
print(a)

#access an element
print(f"a[2].shape: {a[2].shape} a[2]  = {a[2]}, Accessing an element returns a scalar")

# access the last element, negative indexes count from the end
print(f"a[-1] = {a[-1]}")

#indexs must be within the range of the vector or they will produce and error
try:
    c = a[10]
except Exception as e:
    print("The error message you'll see is:")
    print(e)
```
- A code to understand indexing

![image](https://github.com/user-attachments/assets/9908ed14-d334-40d7-85eb-6a1a1d5d4c7d)

- A code to understand Slicing
```
#vector slicing operations
a = np.arange(10)
print(f"a         = {a}")

#access 5 consecutive elements (start:stop:step)
c = a[2:7:1];     print("a[2:7:1] = ", c)

# access 3 elements separated by two 
c = a[2:7:2];     print("a[2:7:2] = ", c)

# access all elements index 3 and above
c = a[3:];        print("a[3:]    = ", c)

# access all elements below index 3
c = a[:3];        print("a[:3]    = ", c)

# access all elements
c = a[:];         print("a[:]     = ", c)
```

![image](https://github.com/user-attachments/assets/72ee8093-e636-41ec-94cf-839ae30c2637)
---
![image](https://github.com/user-attachments/assets/67686e8d-b892-4c86-98cd-8285403365d0)
---

![image](https://github.com/user-attachments/assets/4c6d78f9-d600-4b04-8ffe-2d44b63d9fcc)
---
![image](https://github.com/user-attachments/assets/689b9720-2837-4a80-9f44-4535530dd865)
---
